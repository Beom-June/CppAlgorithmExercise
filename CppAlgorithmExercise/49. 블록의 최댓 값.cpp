/*문제 49. 블록의 최댓 값
현수는 블록놀이를 좋아합니다.현수에게 정면에서 본 단면과 오른쪽 측면에서 본 단면을 주고 최대 블록개수를 사용하여 정면과 오른쪽 측면에서 본 모습으로 블록을 쌓으라 했습니다.
현수가 블록을 쌓는데 사용해야 할 최대 개수를 출력하는 프로그램을 작성하세요.
정면

오른쪽 측면

2 3 1
2 2 1
1 1 1
1 1 1
위에서 본 높이(최대개수)

위에서 봤을 때 각 칸의 블록의 개수입니다.정면에서의 높이 정보와 오른쪽 측면에서의 높이 정보가 주어지면 사용할 수 있는 블록의 쵀대 개수를 출력하세요.
▣ 입력설명
첫 줄에 블록의 크기 N(3 <= N <= 10)이 주어집니다.블록이 크기는 정사각형 N * N입니다.
두 번째 줄에 N개의 정면에서의 높이 정보가 왼쪽 정보부터 주어집니다.
세 번째 줄에 N개의 오른쪽 측면 높이 정보가 앞쪽부터 주어집니다.
블록의 높이는 10 미만입니다.

▣ 출력설명
첫 줄에 블록의 최대 개수를 출력합니다.

▣ 입력예제 1
4
2 0 3 1
1 1 2 3

▣ 출력예제 1
17
*/

#include<stdio.h>
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

/*
int a[11][11];
int b[11];			// 정면 정보

int main()
{
	int n, sum = 0, i, j;

	cin >> n;

	// 정면
	for (i = 1; i <= n; i++)
	{
		cin >> b[i];
	}

	// 전체 채워 넣기
	for (i = 1; i <= n; i++)
	{
		for (j = 1; j <= n; j++)
		{
			// a[j][i] 한 이유 -> 행을 먼저 채우기 위해서
			a[j][i] = b[i];
		}
	}

	// 오른쪽 측면 정보 -> 거꾸로 받음
	for (i = n; i >= 1; i--)
		cin >> b[i];

	// 깍아내는 부분
	for (i = 1; i <= n; i++)
	{
		for (j = 1; j <= n; j++)
		{
			if (a[i][j] > b[i])
			{
				a[i][j] = b[i];
			}
		}
	}

	// 전체 갯수 더하는 부분
	for (i = 1; i <= n; i++)
	{
		for (j = 1; j <= n; j++)
		{
			sum += a[i][j];
		}
	}
	cout << sum;
	return 0;
}
*/